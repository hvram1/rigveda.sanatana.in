---
import BaseLayout from '../layouts/BaseLayout.astro';
const base = import.meta.env.BASE_URL;
---

<BaseLayout title="अन्वेषणम् - Search">
  <meta name="base-url" content={base} />
  <div class="search-container">
    <h1 class="text-2xl font-bold text-maroon mb-6 text-center">अन्वेषणम् (Search)</h1>
    
    <div class="search-box">
      <input 
        type="text" 
        id="search-input" 
        placeholder="Search verses... (e.g., अग्निमीळे, इन्द्र, सोम)"
        class="search-input"
        autofocus
      />
      <button id="search-btn" class="search-btn">
        Search
      </button>
    </div>

    <div class="search-options">
      <label class="option-label">
        <input type="checkbox" id="phonetic-mode" checked />
        <span>Phonetic matching (matches similar sounds: द/ध, त/थ, इ/ई, etc.)</span>
      </label>
    </div>

    <div class="highlight-legend">
      <span class="legend-item"><span class="legend-color exact"></span> Exact match</span>
      <span class="legend-item"><span class="legend-color phonetic"></span> Phonetic match</span>
    </div>

    <div class="quick-links">
      <a href={base}>मुख्यपृष्ठम्</a>
      <a href={`${base}rishi`}>ऋषयः</a>
      <a href={`${base}devata`}>देवताः</a>
      <a href={`${base}chandas`}>छन्दांसि</a>
      <a href={`${base}samanapada`}>समानपदमन्त्राः</a>
    </div>

    <div id="search-status" class="search-status"></div>
    
    <div id="did-you-mean" class="did-you-mean"></div>

    <div id="search-results" class="search-results"></div>
  </div>
</BaseLayout>

<script>
  import Fuse from 'fuse.js';
  
  // Get base URL from meta tag
  const base = document.querySelector('meta[name="base-url"]')?.getAttribute('content') || '/';

  // Phonetic normalization (same as server-side)
  const SVARA_MARKS = /[॒॑᳚]/g;
  const PHONETIC_MAP: [RegExp, string][] = [
    [/ख/g, 'क'], [/घ/g, 'ग'], [/छ/g, 'च'], [/झ/g, 'ज'],
    [/ठ/g, 'ट'], [/ढ/g, 'ड'], [/थ/g, 'त'], [/ध/g, 'द'],
    [/फ/g, 'प'], [/भ/g, 'ब'],
    [/श/g, 'स'], [/ष/g, 'स'],
    [/ण/g, 'न'], [/ङ/g, 'न'], [/ञ/g, 'न'],
    [/ळ/g, 'ल'],
    [/आ/g, 'अ'], [/ई/g, 'इ'], [/ऊ/g, 'उ'], [/ऐ/g, 'ए'], [/औ/g, 'ओ'], [/ॠ/g, 'ऋ'],
    [/ं/g, 'म'], [/ँ/g, ''], [/ः/g, ''], [/ऽ/g, ''],
  ];

  function stripSvara(text: string): string {
    return text.replace(SVARA_MARKS, '');
  }

  function phoneticKey(text: string): string {
    let result = stripSvara(text);
    for (const [pattern, replacement] of PHONETIC_MAP) {
      result = result.replace(pattern, replacement);
    }
    return result.replace(/[\s।॥,\.\-]+/g, ' ').trim().toLowerCase();
  }

  // Reverse phonetic map for suggestions
  const PHONETIC_SUGGESTIONS: { [key: string]: string[] } = {
    'क': ['क', 'ख'], 'ग': ['ग', 'घ'], 'च': ['च', 'छ'], 'ज': ['ज', 'झ'],
    'ट': ['ट', 'ठ'], 'ड': ['ड', 'ढ'], 'त': ['त', 'थ'], 'द': ['द', 'ध'],
    'प': ['प', 'फ'], 'ब': ['ब', 'भ'],
    'स': ['स', 'श', 'ष'],
    'न': ['न', 'ण', 'ङ', 'ञ'],
    'ल': ['ल', 'ळ'],
    'अ': ['अ', 'आ'], 'इ': ['इ', 'ई'], 'उ': ['उ', 'ऊ'], 'ए': ['ए', 'ऐ'], 'ओ': ['ओ', 'औ'],
  };

  interface SearchItem {
    id: string;
    m: number;
    s: number;
    r: number;
    t: string;  // text
    p: string;  // phonetic
    ri: string; // rishi
    de: string; // devata
  }

  let searchIndex: SearchItem[] = [];
  let fuse: Fuse<SearchItem> | null = null;
  let fusePhonetic: Fuse<SearchItem> | null = null;

  const searchInput = document.getElementById('search-input') as HTMLInputElement;
  const searchBtn = document.getElementById('search-btn') as HTMLButtonElement;
  const searchStatus = document.getElementById('search-status') as HTMLDivElement;
  const didYouMean = document.getElementById('did-you-mean') as HTMLDivElement;
  const searchResults = document.getElementById('search-results') as HTMLDivElement;
  const phoneticMode = document.getElementById('phonetic-mode') as HTMLInputElement;

  // Load search index
  async function loadIndex() {
    searchStatus.textContent = 'Loading search index...';
    try {
      const response = await fetch(`${base}search-index.json`);
      searchIndex = await response.json();
      
      // Initialize Fuse for text search
      fuse = new Fuse(searchIndex, {
        keys: ['t', 'ri', 'de'],
        threshold: 0.3,
        includeScore: true,
        ignoreLocation: true,
      });

      // Initialize Fuse for phonetic search
      fusePhonetic = new Fuse(searchIndex, {
        keys: ['p'],
        threshold: 0.2,
        includeScore: true,
        ignoreLocation: true,
      });

      searchStatus.textContent = `Ready. ${searchIndex.length.toLocaleString()} verses indexed.`;
    } catch (err) {
      searchStatus.textContent = 'Error loading search index.';
      console.error(err);
    }
  }

  function performSearch() {
    const query = searchInput.value.trim();
    if (!query || !fuse || !fusePhonetic) return;

    const usePhonetic = phoneticMode.checked;
    const startTime = performance.now();

    let results: Fuse.FuseResult<SearchItem>[];
    
    const MAX_RESULTS = 20;
    
    if (usePhonetic) {
      // Search using phonetic key
      const phoneticQuery = phoneticKey(query);
      results = fusePhonetic.search(phoneticQuery, { limit: 50 });
      
      // Also do exact text search and merge results
      const textResults = fuse.search(query, { limit: 30 });
      
      // Combine and dedupe
      const seen = new Set<string>();
      const combined: Fuse.FuseResult<SearchItem>[] = [];
      
      for (const r of textResults) {
        if (!seen.has(r.item.id)) {
          seen.add(r.item.id);
          combined.push(r);
        }
      }
      for (const r of results) {
        if (!seen.has(r.item.id)) {
          seen.add(r.item.id);
          combined.push(r);
        }
      }
      results = combined.slice(0, MAX_RESULTS);
    } else {
      results = fuse.search(query, { limit: MAX_RESULTS });
    }

    const elapsed = (performance.now() - startTime).toFixed(1);
    
    // Show "did you mean" suggestions if query has potential phonetic variants
    showDidYouMean(query);

    // Display results
    if (results.length === 0) {
      searchStatus.textContent = `No results found for "${query}" (${elapsed}ms)`;
      searchResults.innerHTML = '<p class="no-results">No verses found. Try different spelling or enable phonetic matching.</p>';
    } else {
      searchStatus.textContent = `Found ${results.length} results for "${query}" (${elapsed}ms)`;
      searchResults.innerHTML = results.map(r => renderResult(r.item, query)).join('');
    }
  }

  function showDidYouMean(query: string) {
    if (!phoneticMode.checked) {
      didYouMean.innerHTML = '';
      return;
    }

    // Generate alternative spellings
    const alternatives = new Set<string>();
    const chars = query.split('');
    
    for (let i = 0; i < chars.length; i++) {
      const char = chars[i];
      // Find if this char has phonetic equivalents
      for (const [base, variants] of Object.entries(PHONETIC_SUGGESTIONS)) {
        if (variants.includes(char)) {
          for (const variant of variants) {
            if (variant !== char) {
              const alt = [...chars];
              alt[i] = variant;
              alternatives.add(alt.join(''));
            }
          }
        }
      }
    }

    if (alternatives.size > 0 && alternatives.size <= 10) {
      const links = Array.from(alternatives).map(alt => 
        `<a href="#" class="suggestion-link" data-query="${alt}">${alt}</a>`
      ).join(', ');
      didYouMean.innerHTML = `<span class="did-you-mean-label">Also searching for:</span> ${links}`;
      
      // Add click handlers
      didYouMean.querySelectorAll('.suggestion-link').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          searchInput.value = (e.target as HTMLAnchorElement).dataset.query || '';
          performSearch();
        });
      });
    } else {
      didYouMean.innerHTML = '';
    }
  }

  // Build phonetic equivalents map for highlighting
  const PHONETIC_EQUIVALENTS: { [key: string]: string[] } = {
    'क': ['ख'], 'ख': ['क'],
    'ग': ['घ'], 'घ': ['ग'],
    'च': ['छ'], 'छ': ['च'],
    'ज': ['झ'], 'झ': ['ज'],
    'ट': ['ठ'], 'ठ': ['ट'],
    'ड': ['ढ'], 'ढ': ['ड'],
    'त': ['थ'], 'थ': ['त'],
    'द': ['ध'], 'ध': ['द'],
    'प': ['फ'], 'फ': ['प'],
    'ब': ['भ'], 'भ': ['ब'],
    'स': ['श', 'ष'], 'श': ['स', 'ष'], 'ष': ['स', 'श'],
    'न': ['ण', 'ङ', 'ञ'], 'ण': ['न'], 'ङ': ['न'], 'ञ': ['न'],
    'ल': ['ळ'], 'ळ': ['ल'],
    'अ': ['आ'], 'आ': ['अ'],
    'इ': ['ई'], 'ई': ['इ'],
    'उ': ['ऊ'], 'ऊ': ['उ'],
    'ए': ['ऐ'], 'ऐ': ['ए'],
    'ओ': ['औ'], 'औ': ['ओ'],
  };

  function getPhoneticVariants(query: string): string[] {
    const variants: string[] = [];
    const chars = query.split('');
    
    // Generate variants by replacing each char with its phonetic equivalents
    for (let i = 0; i < chars.length; i++) {
      const char = chars[i];
      const equivalents = PHONETIC_EQUIVALENTS[char];
      if (equivalents) {
        for (const eq of equivalents) {
          const variant = [...chars];
          variant[i] = eq;
          variants.push(variant.join(''));
        }
      }
    }
    return variants;
  }

  function renderResult(item: SearchItem, query: string): string {
    const highlightWithColors = (text: string) => {
      if (!query) return text;
      
      let result = text;
      
      // First, highlight exact matches (yellow/gold)
      const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const exactRegex = new RegExp(`(${escapedQuery})`, 'gi');
      result = result.replace(exactRegex, '<mark class="exact-match">$1</mark>');
      
      // Then, highlight phonetic variants (light blue)
      if (phoneticMode.checked) {
        const variants = getPhoneticVariants(query);
        for (const variant of variants) {
          const escapedVariant = variant.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const variantRegex = new RegExp(`(${escapedVariant})`, 'gi');
          // Only highlight if not already highlighted
          result = result.replace(variantRegex, (match) => {
            // Check if already inside a mark tag
            const before = result.substring(0, result.indexOf(match));
            const openTags = (before.match(/<mark/g) || []).length;
            const closeTags = (before.match(/<\/mark>/g) || []).length;
            if (openTags > closeTags) {
              return match; // Already highlighted
            }
            return `<mark class="phonetic-match">${match}</mark>`;
          });
        }
      }
      
      return result;
    };

    return `
      <a href="${base}rik/${item.m}/${item.s}/${item.r}" class="result-item">
        <div class="result-header">
          <span class="result-id">${item.id}</span>
          <span class="result-arrow">→</span>
        </div>
        <div class="result-text">${highlightWithColors(item.t)}</div>
        <div class="result-meta">
          <span class="meta-label">ऋषिः:</span> ${item.ri} 
          <span class="meta-sep">|</span>
          <span class="meta-label">देवता:</span> ${item.de}
        </div>
      </a>
    `;
  }

  // Event listeners
  searchBtn.addEventListener('click', performSearch);
  searchInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') performSearch();
  });

  // Load index on page load
  loadIndex();
</script>

<style>
  .search-container {
    max-width: 800px;
    margin: 0 auto;
    padding: 2rem 1rem;
  }

  .search-box {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
  }

  .search-input {
    flex: 1;
    padding: 0.75rem 1rem;
    font-size: 1.1rem;
    font-family: 'AdiShilaVedic', serif;
    border: 2px solid #ddd;
    border-radius: 8px;
    outline: none;
    transition: border-color 0.2s;
  }

  .search-input:focus {
    border-color: var(--color-golden);
  }

  .search-btn {
    padding: 0.75rem 1.5rem;
    background: var(--color-maroon);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 1rem;
    cursor: pointer;
    transition: background 0.2s;
  }

  .search-btn:hover {
    background: var(--color-primary);
  }

  .search-options {
    margin-bottom: 1rem;
  }

  .option-label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.9rem;
    color: #666;
    cursor: pointer;
  }

  .option-label input {
    width: 18px;
    height: 18px;
  }

  .highlight-legend {
    display: flex;
    gap: 1.5rem;
    margin-bottom: 1rem;
    font-size: 0.85rem;
    color: #666;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 0.4rem;
  }

  .legend-color {
    display: inline-block;
    width: 16px;
    height: 16px;
    border-radius: 3px;
  }

  .legend-color.exact {
    background: #fff3cd;
  }

  .legend-color.phonetic {
    background: #d4edfc;
  }

  .quick-links {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-bottom: 1.5rem;
    padding: 0.75rem;
    background: #f8f8f8;
    border-radius: 8px;
  }

  .quick-links a {
    padding: 0.4rem 0.75rem;
    background: white;
    border-radius: 4px;
    font-size: 0.85rem;
    font-family: 'AdiShilaVedic', serif;
    color: var(--color-maroon);
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    transition: all 0.15s;
  }

  .quick-links a:hover {
    background: var(--color-golden);
    color: white;
  }

  .search-status {
    font-size: 0.9rem;
    color: #666;
    margin-bottom: 0.5rem;
  }

  .did-you-mean {
    font-size: 0.9rem;
    color: #666;
    margin-bottom: 1rem;
    padding: 0.5rem;
    background: #fff9f0;
    border-radius: 4px;
  }

  .did-you-mean:empty {
    display: none;
  }

  .did-you-mean-label {
    color: #888;
  }

  .suggestion-link {
    color: var(--color-primary);
    font-family: 'AdiShilaVedic', serif;
  }

  .suggestion-link:hover {
    text-decoration: underline;
  }

  .search-results {
    margin-top: 1rem;
  }

  .result-item {
    display: block;
    background: white;
    border-radius: 8px;
    padding: 1rem 1.25rem;
    margin-bottom: 0.75rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.08);
    border-left: 4px solid var(--color-golden);
    transition: all 0.2s;
    text-decoration: none;
    color: inherit;
  }

  .result-item:hover {
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    border-left-color: var(--color-maroon);
    transform: translateX(4px);
  }

  .result-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.75rem;
  }

  .result-id {
    font-weight: 700;
    color: var(--color-maroon);
    font-size: 1.2rem;
    font-family: 'AdiShilaVedic', serif;
  }

  .result-item:hover .result-id {
    color: var(--color-primary);
  }

  .result-arrow {
    font-size: 1.2rem;
    color: var(--color-golden);
    transition: transform 0.2s;
  }

  .result-item:hover .result-arrow {
    transform: translateX(4px);
    color: var(--color-maroon);
  }

  .result-meta {
    font-size: 0.8rem;
    color: #666;
    margin-top: 0.75rem;
    padding-top: 0.5rem;
    border-top: 1px solid #eee;
  }

  .meta-label {
    color: #999;
  }

  .meta-sep {
    color: #ccc;
    margin: 0 0.5rem;
  }

  .result-text {
    font-family: 'AdiShilaVedic', serif;
    font-size: 1.1rem;
    color: #333;
    line-height: 1.6;
  }

  .result-text :global(mark.exact-match) {
    background: #fff3cd;
    padding: 0 2px;
    border-radius: 2px;
  }

  .result-text :global(mark.phonetic-match) {
    background: #d4edfc;
    padding: 0 2px;
    border-radius: 2px;
  }

  .no-results {
    text-align: center;
    color: #666;
    padding: 2rem;
  }

  @media (max-width: 600px) {
    .search-box {
      flex-direction: column;
    }

    .search-btn {
      width: 100%;
    }

    .result-header {
      flex-direction: column;
      align-items: flex-start;
      gap: 0.25rem;
    }

    .result-meta {
      font-size: 0.75rem;
    }
  }
</style>
